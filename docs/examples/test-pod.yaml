# Exemplo de Test Pod - Helm Tests

apiVersion: v1
kind: Pod
metadata:
  name: "{{ .Release.Name }}-{{ .Chart.Name }}-test"
  namespace: "{{ .Release.Namespace }}"
  labels:
    app.kubernetes.io/name: "{{ .Chart.Name }}"
    app.kubernetes.io/instance: "{{ .Release.Name }}"
    app.kubernetes.io/version: { ? { .Chart.AppVersion | quote } }
    app.kubernetes.io/component: "test"
    app.kubernetes.io/part-of: "{{ .Chart.Name }}"
    app.kubernetes.io/managed-by: "{{ .Release.Service }}"
  annotations:
    "helm.sh/hook": test
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  restartPolicy: Never
  containers:
  - name: test
    image: curlimages/curl:latest
    command:
    - /bin/sh
    - -c
    - |
      set -e
      echo "üß™ Iniciando testes do {{ .Chart.Name }}..."

      # =================================================================
      # TESTE 1: Conectividade com Service
      # =================================================================
      echo "‚úÖ Testando conectividade com service..."
      SERVICE_URL="http://{{ .Release.Name }}-{{ .Chart.Name }}:80"

      # Aguardar service estar dispon√≠vel
      for i in $(seq 1 30); do
        if curl -f --connect-timeout 5 $SERVICE_URL/ >/dev/null 2>&1; then
          echo "‚úÖ Service respondendo em $SERVICE_URL"
          break
        fi
        echo "‚è≥ Aguardando service... (tentativa $i/30)"
        sleep 2
      done

      # Testar se service responde
      curl -f --connect-timeout 10 $SERVICE_URL/ || {
        echo "‚ùå Service n√£o est√° respondendo em $SERVICE_URL"
        exit 1
      }

      # =================================================================
      # TESTE 2: Verificar IngressRoute (se domain configurado)
      # =================================================================
      {{- if .Values.domain }}
      echo "‚úÖ Verificando IngressRoute para {{ .Values.domain }}..."

      # Verificar se IngressRoute existe
      if ! nslookup {{ .Values.domain }} >/dev/null 2>&1; then
        echo "‚ö†Ô∏è  DNS n√£o configurado para {{ .Values.domain }} (normal em teste)"
      else
        echo "‚úÖ DNS configurado para {{ .Values.domain }}"
      fi
      {{- end }}

      # =================================================================
      # TESTE 3: Autentica√ß√£o (se habilitada)
      # =================================================================
      {{- if .Values.auth.enabled }}
      echo "‚úÖ Testando autentica√ß√£o..."

      # Testar acesso sem credenciais (deve falhar)
      if curl -f --connect-timeout 10 $SERVICE_URL/ >/dev/null 2>&1; then
        echo "‚ùå Autentica√ß√£o n√£o est√° funcionando - acesso permitido sem credenciais"
        exit 1
      else
        echo "‚úÖ Autentica√ß√£o funcionando - acesso negado sem credenciais"
      fi

      # Testar com credenciais (se configuradas)
      {{- if and .Values.auth.username .Values.auth.password }}
      echo "‚úÖ Testando acesso com credenciais..."
      if curl -f --connect-timeout 10 -u "{{ .Values.auth.username }}:{{ .Values.auth.password }}" $SERVICE_URL/ >/dev/null 2>&1; then
        echo "‚úÖ Autentica√ß√£o com credenciais funcionando"
      else
        echo "‚ö†Ô∏è  Credenciais podem estar incorretas ou endpoint n√£o suporta basic auth"
      fi
      {{- end }}
      {{- end }}

      # =================================================================
      # TESTE 4: Health Checks (se habilitados)
      # =================================================================
      {{- if .Values.healthcheck.enabled }}
      echo "‚úÖ Testando health checks..."

      {{- if .Values.healthcheck.liveness.enabled }}
      HEALTH_PATH="{{ .Values.healthcheck.liveness.path | default "/health" }}"
      echo "‚úÖ Testando liveness probe em $HEALTH_PATH..."
      curl -f --connect-timeout 10 "$SERVICE_URL$HEALTH_PATH" || {
        echo "‚ùå Liveness probe falhando em $SERVICE_URL$HEALTH_PATH"
        exit 1
      }
      echo "‚úÖ Liveness probe funcionando"
      {{- end }}

      {{- if .Values.healthcheck.readiness.enabled }}
      READY_PATH="{{ .Values.healthcheck.readiness.path | default "/ready" }}"
      echo "‚úÖ Testando readiness probe em $READY_PATH..."
      curl -f --connect-timeout 10 "$SERVICE_URL$READY_PATH" || {
        echo "‚ùå Readiness probe falhando em $SERVICE_URL$READY_PATH"
        exit 1
      }
      echo "‚úÖ Readiness probe funcionando"
      {{- end }}
      {{- end }}

      # =================================================================
      # TESTE 5: Verificar Recursos Kubernetes
      # =================================================================
      echo "‚úÖ Verificando recursos Kubernetes..."

      # Verificar se Deployment existe e est√° ready
      if command -v kubectl >/dev/null 2>&1; then
        echo "üì¶ Verificando Deployment..."
        kubectl get deployment "{{ .Release.Name }}-{{ .Chart.Name }}" -n "{{ .Release.Namespace }}" || {
          echo "‚ùå Deployment n√£o encontrado"
          exit 1
        }
        
        echo "üåê Verificando Service..."
        kubectl get service "{{ .Release.Name }}-{{ .Chart.Name }}" -n "{{ .Release.Namespace }}" || {
          echo "‚ùå Service n√£o encontrado"
          exit 1
        }
        
        {{- if .Values.domain }}
        echo "üö™ Verificando IngressRoute..."
        kubectl get ingressroute "{{ .Release.Name }}-{{ .Chart.Name }}" -n "{{ .Release.Namespace }}" || {
          echo "‚ùå IngressRoute n√£o encontrado"
          exit 1
        }
        {{- end }}
        
        {{- if .Values.persistence.enabled }}
        echo "üíæ Verificando PVC..."
        kubectl get pvc "{{ .Release.Name }}-{{ .Chart.Name }}-data" -n "{{ .Release.Namespace }}" || {
          echo "‚ùå PVC n√£o encontrado"
          exit 1
        }
        {{- end }}
        
        echo "‚úÖ Todos os recursos Kubernetes encontrados"
      else
        echo "‚ö†Ô∏è  kubectl n√£o dispon√≠vel - pulando verifica√ß√£o de recursos"
      fi

      # =================================================================
      # TESTE 6: Labels e Naming (Conformidade)
      # =================================================================
      echo "‚úÖ Verificando conformidade de labels e naming..."

      # Verificar se response tem headers corretos (se aplic√°vel)
      if curl -I --connect-timeout 10 $SERVICE_URL/ 2>/dev/null | grep -i "server:" >/dev/null; then
        echo "‚úÖ Service retornando headers HTTP"
      fi

      # =================================================================
      # FINALIZANDO TESTES
      # =================================================================
      echo ""
      echo "üéâ ================================================"
      echo "üéâ TODOS OS TESTES PASSARAM COM SUCESSO!"
      echo "üéâ Chart {{ .Chart.Name }} est√° funcionando corretamente"
      echo "üéâ Release: {{ .Release.Name }}"
      echo "üéâ Namespace: {{ .Release.Namespace }}"
      echo "üéâ ================================================"
      echo ""

# PADR√ïES PARA HELM TESTS:
# ========================
#
# 1. LABELS OBRIGAT√ìRIAS:
#    - Todas as 6 labels kubernetes.io padr√£o
#    - app.kubernetes.io/component: "test"
#
# 2. ANNOTATIONS HELM:
#    - "helm.sh/hook": test
#    - "helm.sh/hook-weight": "1" (ordem de execu√ß√£o)
#    - "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
#
# 3. SPEC DO CONTAINER:
#    - restartPolicy: Never (obrigat√≥rio para tests)
#    - image: curlimages/curl:latest (leve e com ferramentas)
#    - command: shell script com testes
#
# 4. ESTRUTURA DOS TESTES:
#    - set -e (falha no primeiro erro)
#    - Echo informativos com emojis
#    - Testes condicionais baseados em .Values
#    - Exit codes apropriados (0=sucesso, 1=falha)
#
# 5. TIPOS DE TESTE RECOMENDADOS:
#    - Conectividade com Service
#    - Health checks (se habilitados)
#    - Autentica√ß√£o (se habilitada)
#    - Recursos Kubernetes existem
#    - IngressRoute configurado (se domain definido)
#
# 6. BOAS PR√ÅTICAS:
#    - Timeouts em todas as requisi√ß√µes
#    - Retry logic para recursos que demoram
#    - Logs claros e informativos
#    - N√£o assumir recursos externos (DNS, etc.)
#    - Testar apenas o que o chart controla

# =================================================================
# PERSONALIZA√á√ÉO POR TIPO DE APLICA√á√ÉO
# =================================================================
#
# Para BANCOS DE DADOS:
# - Testar conex√£o TCP em vez de HTTP
# - Verificar se aceita conex√µes
# - Testar cria√ß√£o de database/schema b√°sico
#
# Para APIs REST:
# - Testar endpoints espec√≠ficos (/api/health, /api/version)
# - Verificar formato de resposta JSON
# - Testar autentica√ß√£o JWT/OAuth
#
# Para APLICA√á√ïES WEB:
# - Testar p√°gina inicial (/)
# - Verificar assets est√°ticos (/css, /js)
# - Testar formul√°rios b√°sicos
#
# Para WORKERS/BACKGROUND:
# - Verificar se processo est√° rodando
# - Testar processamento de filas
# - Verificar logs de atividade 
